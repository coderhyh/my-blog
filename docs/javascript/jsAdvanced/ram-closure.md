---
title: 内存管理和闭包
date: 2022-07-20
sidebar: 'auto'
tags:
 - 笔记
 - js
categories:
 - javascript
---



## 认识内存管理

1. 不管什么样的编程语言，在**代码的执行过程中都是需要给它分配内存**的，不同的是某些编程语言需要我们**自己手动的管理内存**，某些编程语言会可以**自动帮助我们管理内存**；
2. 不管以什么样的方式来管理内存，内存的管理都会有如下的生命周期：
   - 第一步：分配申请你需要的内存（申请）；
   - 第二步：使用分配的内存（存放一些东西，比如对象等）；
   - 第三步：不需要使用时，对其进行释放；
3. 不同的编程语言对于第一步和第三步会有不同的实现：
   - 手动管理内存：比如C、C++，包括早期的OC，都是需要手动来管理内存的申请和释放的（malloc和free函 数）；
   - 自动管理内存：比如Java、JavaScript、Python、Swift、Dart等，它们有自动帮助我们管理内存；
4. 我们可以知道JavaScript通常情况下是不需要手动来管理的。

## JS的内存管理

1. JavaScript会在定义变量时为我们分配内存。

2. 但是内存分配方式是一样的吗？

   - JS对于**基本数据类型内存的分配**会在执行时， 直接在栈空间进行分配；
   - JS对于**复杂数据类型内存的分配**会在堆内存 中开辟一块空间，并且将这块空间的指针返 回值变量引用；

   <img src="/javascript/ram-closure/image-20220720151647789.png" alt="image-20220720151647789" style="zoom: 67%;" />

## JS的垃圾回收

1. 因为内存的大小是**有限的**，所以当内存不再需要的时候，我们需要**对其进行释放**，以便**腾出更多的内存空间**。
2. 在**手动管理内存的语言**中，我们需要通过一些方式自己来释放不再需要的内存，比如`free`函数：
   - 但是这种管理的方式其实**非常的低效**，影响我们编写逻辑的代码的效率；
   - 并且这种方式对**开发者的要求也很高**，并且一不小心就会**产生内存泄露**；
3. 所以大部分现代的编程语言都是有自己的垃圾回收机制：
   - 垃圾回收的英文是**Garbage Collection**，简称**GC**；
   - 对于那些**不再使用的对象**，我们都称之为是**垃圾**，它需要被**回收**，以**释放更多的内存空间**；
   - 而我们的语言运行环境，比如Java的运行环境JVM，JavaScript的运行环境js引擎都会内存 **垃圾回收器**；
   - **垃圾回收器**我们也会**简称为GC**，所以在很多地方你看到**GC其实指的是垃圾回收器**；
4. 但是这里又出现了另外一个很关键的问题：GC怎么知道哪些对象是不再使用的呢？
   - 这里就要用到**GC的算法**了

## 常见的GC算法 

1. 引用计数

   - 当一个对象有一个**引用指向它时**，那么这个**对象的引用就+1**，当一个对象的引用为0时，这个对象就可以**被销 毁掉**；
   - 这个算法有一个很大的弊端就是会产生循环引用；

   <img src="/javascript/ram-closure/image-20220720152101495.png" alt="image-20220720152101495" style="zoom:67%;" />

2. 标记清除

   - 这个算法是设置一个**根对象（root object）**，垃圾回收器会定期从这个根开始，找所有从**根开始有引用到的对象**，对于那些**没有引用到的对象**，就认为是**不可用的对象**；
   - 这个算法可以很好的解决循环引用的问题；

   <img src="/javascript/ram-closure/image-20220720152136960.png" alt="image-20220720152136960" style="zoom:80%;" />

   - JS引擎比较广泛的采用的就是标记清除算法，当然类似于V8引擎为了进行更好的优化，它在算法的实现细节上也会结合 一些其他的算法。



## JS中闭包的定义

这里先来看一下闭包的定义，分成两个：在计算机科学中和在JavaScript中。

1. 在计算机科学中对闭包的定义（维基百科）：
   - 闭包（英语：Closure），又称**词法闭包**（Lexical Closure）或**函数闭包**（function closures）；
   - 是在支持**头等函数**的编程语言中，实现词法绑定的一种技术；
   - 闭包在实现上是一个结构体，它存储了一个函数和一个关联的环境（相当于一个符号查找表）；
   - 闭包跟函数最大的区别在于，当捕捉闭包的时候，它的**自由变量**会在补充时被确定，这样即使脱离了捕捉时的上下文，它也能照常运行；
2. 闭包的概念出现于60年代，最早实现闭包的程序是 Scheme，那么我们就可以理解为什么JavaScript中有闭包：
   - 因为JavaScript中有大量的设计是来源于Scheme的；
3. 我们再来看一下MDN对JavaScript闭包的解释：
   - 一个函数和对其周围状态（**lexical environment**，**词法环境**）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是**闭包**（closure）；
   - 也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域；
   - 在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来；
4. 理解和总结：
   - 一个普通的函数function，如果它可以访问外层作用于的自由变量，那么这个函数就是一个闭包；
   - 从广义的角度来说：JavaScript中的函数都是闭包；
   - 从狭义的角度来说：JavaScript中一个函数，如果访问了外层作用于的变量，那么它是一个闭包

## 函数闭包的执行过程

那么为什么闭包之后 AO中的 name变量不会被销毁呢？

- 因为上面讲过GC算法的**标记清除**，他会从**根对象**查找，如果有一个对象没有被引用，那么就会被回收
- 这里因为bar函数中引用了name，所以会被保留
- 在ecma中只要有一个**自由变量**被引用，那么这个AO就都不会被清除
- 而在v8中是做了优化，只有被引用到的**自由变量**会被保留，其他的都会被清除



![image-20220721160133664](/javascript/ram-closure/image-20220721160133664.png)